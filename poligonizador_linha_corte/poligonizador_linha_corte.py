# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PoligonizadorLinhaCorte
                                 A QGIS plugin
 Plugin para poligonizar linhas de corte e gerar lotes automaticamente
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-10-10
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Geotecnologia
        email                : Geotecnologia@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QMessageBox
from qgis.core import (QgsProcessing, QgsProcessingMultiStepFeedback, 
                       QgsProviderRegistry, QgsCoordinateReferenceSystem, 
                       QgsProject, QgsVectorLayer)
from qgis.gui import QgsMapToolIdentifyFeature
import processing

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .poligonizador_linha_corte_dialog import PoligonizadorDialog
from.services.Notification import show_notification
import os.path


class PoligonizadorLinhaCorte:
    """QGIS Plugin Implementation."""
#Construtor da classe - inicializa o plugin quando o QGIS o carrega.
    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'PoligonizadorLinhaCorte_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Poligonizador de Linha de Corte')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        
        # Atributos para seleção de quadra
        self.quadra_selecionada = None
        self.map_tool = None
        self.previous_map_tool = None

    # Traduz textos do plugin para o idioma do usuário.
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('PoligonizadorLinhaCorte', message)

#Cria botões e itens de menu para o plugin.
    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action
#Cria a interface visual do plugin no QGIS.
    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/poligonizador_linha_corte/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Desenhar Lote'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True
#Remove o plugin do QGIS quando descarregado.
    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Poligonizador de Linha de Corte'),
                action)
            self.iface.removeToolBarIcon(action)
        
        # Restaura a ferramenta de mapa anterior se existir
        if self.previous_map_tool:
            self.iface.mapCanvas().setMapTool(self.previous_map_tool)

#Preenche o dropdown com conexões PostgreSQL disponíveis.
    def popular_conexoes(self):
        """Popula o combobox com as conexões PostgreSQL disponíveis"""
        self.dlg.combo_conexao.clear()
        
        metadata = QgsProviderRegistry.instance().providerMetadata('postgres')
        if metadata:
            connections = metadata.connections()
            for name, conn in connections.items():
                self.dlg.combo_conexao.addItem(name, name)
        
        if self.dlg.combo_conexao.count() == 0:
            QMessageBox.warning(
                self.dlg,
                "Aviso",
                "Nenhuma conexão PostgreSQL encontrada!\n"
                "Configure uma conexão no Gerenciador de Fontes de Dados."
            )
#Ativa modo de seleção interativa de quadras no mapa.
    def selecionar_quadra(self):
        """Ativa a ferramenta de seleção de quadra no mapa"""
        # Busca a camada Quadra
        quadra_layers = QgsProject.instance().mapLayersByName('Quadra')
        if not quadra_layers:
            show_notification("Aviso", "Camada 'Quadra' não encontrada no projeto", "warning")
           
            return
        
        quadra_layer = quadra_layers[0]
        
        # Minimiza o diálogo para permitir seleção no mapa
        self.dlg.showMinimized()
        
        # Salva a ferramenta de mapa atual
        self.previous_map_tool = self.iface.mapCanvas().mapTool()
        
        # Cria ferramenta de identificação de feição
        self.map_tool = QgsMapToolIdentifyFeature(self.iface.mapCanvas(), quadra_layer)
        self.map_tool.featureIdentified.connect(self.quadra_identificada)
       
        # Ativa a ferramenta de mapa
        self.iface.mapCanvas().setMapTool(self.map_tool)
        
        # Exibe mensagem na barra de status
        self.iface.messageBar().pushMessage(
            "Seleção de Quadras",
            "Clique nas quadras no mapa para selecioná-las. Clique em 'Limpar Seleção' para começar novamente ou feche a janela quando terminar.",
            level=0,
            duration=8
        )
#Remove todas as quadras selecionadas.
    def quadra_identificada(self, feature):
        """Callback chamado quando uma quadra é identificada/selecionada"""
        # Busca a camada Quadra
        quadra_layers = QgsProject.instance().mapLayersByName('Quadra')
        if not quadra_layers:
            return
        
        quadra_layer = quadra_layers[0]
        
        # Adiciona a feição à seleção (ao invés de substituir)
        quadra_layer.select(feature.id())
        self.dlg.showNormal()
        # Atualiza o label ou campo de texto com informações das quadras selecionadas
        num_selecionadas = quadra_layer.selectedFeatureCount()
        info_quadra = f"{num_selecionadas} quadra(s) selecionada(s)"
        
        # Se tiver apenas uma selecionada, mostra os detalhes
        if num_selecionadas == 1:
            info_quadra = self.obter_info_quadra(feature)
        
        # Atualiza o interface
        if hasattr(self.dlg, 'lblQuadraSelecionada'):
            self.dlg.lblQuadraSelecionada.setText(info_quadra)
        
        if hasattr(self.dlg, 'txtQuadraSelecionada'):
            self.dlg.txtQuadraSelecionada.setText(info_quadra)
        
        # Exibe mensagem de confirmação
        show_notification("successo", f"{num_selecionadas} quadra(s) selecionada(s). Continue clicando para adicionar mais", "success",10000)
     
    def limpar_selecao_quadras(self):
        """Limpa a seleção de quadras"""
        quadra_layers = QgsProject.instance().mapLayersByName('Quadra')
        if quadra_layers:
            quadra_layers[0].removeSelection()
            
            # Atualiza interface
            if hasattr(self.dlg, 'lblQuadraSelecionada'):
                self.dlg.lblQuadraSelecionada.setText("Nenhuma quadra selecionada")
            
            if hasattr(self.dlg, 'txtQuadraSelecionada'):
                self.dlg.txtQuadraSelecionada.setText("")
            
            self.iface.messageBar().pushMessage(
                "Seleção Limpa",
                "Todas as quadras foram desmarcadas",
                level=1,
                duration=2
            )
#Extrai e formata informações de uma quadra.
    def finalizar_selecao_quadras(self):
        """Finaliza a seleção de quadras e restaura o diálogo"""
        # Restaura a ferramenta de mapa anterior
        if self.previous_map_tool:
            self.iface.mapCanvas().setMapTool(self.previous_map_tool)
        
        # Restaura o diálogo
       
        
        # Mostra quantas quadras foram selecionadas
        quadra_layers = QgsProject.instance().mapLayersByName('Quadra')
        if quadra_layers:
            num_selecionadas = quadra_layers[0].selectedFeatureCount()
            show_notification("Concluído", f"seleção finalizada, total de{num_selecionadas} quadra(s) selecionada(s) ", "success")
        self.dlg.close()
            
#Extrai e formata informações de uma quadra.
    def obter_info_quadra(self, feature):
        """Obtém informações formatadas da quadra selecionada"""
        info_parts = []
        
        # Tenta obter campos comuns
        if 'id' in feature.fields().names():
            info_parts.append(f"ID: {feature['id']}")
        
        if 'ins_quadra' in feature.fields().names():
            info_parts.append(f"Inscrição: {feature['ins_quadra']}")
        
        if 'id_bairro' in feature.fields().names():
            info_parts.append(f"Bairro: {feature['id_bairro']}")
        
        if 'id_setor' in feature.fields().names():
            info_parts.append(f"Setor: {feature['id_setor']}")
        
        # Se não houver campos, mostra apenas o ID da feição
        if not info_parts:
            info_parts.append(f"Feição ID: {feature.id()}")
        
        return " | ".join(info_parts)
#Adiciona linhas de corte processadas como camada temporária no QGIS.
    def adicionar_linhas_corte_temporarias(self, linhas_output):
        """Adiciona as linhas de corte processadas como uma camada temporária"""
        try:
            # Remove camada anterior se existir
            existing_layers = QgsProject.instance().mapLayersByName("Linhas_corte_processadas")
            for layer in existing_layers:
                QgsProject.instance().removeMapLayer(layer.id())
            
            # Cria camada temporária a partir do output
            temp_layer = QgsVectorLayer(f"{linhas_output}|layername=output", "Linhas_corte_processadas", "ogr")
            
            if temp_layer.isValid():
                QgsProject.instance().addMapLayer(temp_layer)
                
                self.iface.messageBar().pushMessage(
                    "Info",
                    f"Linhas de corte processadas adicionadas ao projeto ({temp_layer.featureCount()} linhas)",
                    level=0,
                    duration=3
                )
            else:
              
                show_notification("ERRO", f"Não foi possível criar camada temporária de linhas de corte", "error")
        except Exception as e:
            import traceback
            show_notification("ERRO", f"Erro ao adicionar linhas de corte temporárias: {str(e)}\n{traceback.format_exc()}", "error")
           
#Atualiza ou cria a camada de lotes no canvas do QGIS.
    def atualizar_camada_lotes(self):
        """Atualiza a camada de lotes no canvas"""
        try:
            # Busca a conexão ativa
            conexao_nome = self.dlg.combo_conexao.currentData()
            if not conexao_nome:
                show_notification("Atenção", f"Não foi possível encontrar uma conexão com banco de dado", "warning")
                return
            
            metadata = QgsProviderRegistry.instance().providerMetadata('postgres')
            if not metadata:
                return
            
            connections = metadata.connections()
            if conexao_nome not in connections:
                return
            
            conn = connections[conexao_nome]
            config = conn.configuration()
            
            # Busca camada existente ao invés de remover
            existing_layers = QgsProject.instance().mapLayersByName("Lote")
            
            if existing_layers:
                # Se a camada já existe, apenas recarrega
                layer = existing_layers[0]
                layer.reload()
                self.iface.mapCanvas().refresh()

                show_notification("Sucesso", f"Camada 'Lote' atualizada com {layer.featureCount()} feições", "success")
               
            else:
                # Se não existe, cria uma nova camada
                # Constrói a URI correta
                uri = f"dbname='{config['database']}' "
                uri += f"host='{config['host']}' "
                uri += f"port='{config['port']}' "
                uri += f"user='{config['username']}' "
                
                if 'password' in config and config['password']:
                    uri += f"password='{config['password']}' "
                
                uri += "sslmode=disable "
                uri += "key='id' "
                uri += "srid=31984 "
                uri += "type=Polygon "
                uri += "checkPrimaryKeyUnicity='1' "
                uri += 'table="comercial_umc"."v_lote" (geom)'
                
                # Cria nova camada
                layer = QgsVectorLayer(uri, "Lote", "postgres")
                
                if layer.isValid():
                    QgsProject.instance().addMapLayer(layer)
                    

                    show_notification("Sucesso", f"Camada 'Lote' criada com {layer.featureCount()} feições", "success")
                   
                else:
                    error_msg = layer.error().message()
                    show_notification("Aviso", f"Não foi possível carregar a camada de lotes:\n{error_msg}", "warning")
                   
        except Exception as e:
            import traceback
            show_notification("Erro", f"Erro ao atualizar camada de lotes: {str(e)}\n{traceback.format_exc()}", "error")
    
#Executa todo o processo de transformar quadras + linhas em lotes - PRINCIPAL
    def executar_poligonizacao(self, conexao_nome):
        """Executa o processo de poligonização"""
        try:
            # Verifica se há feições selecionadas na camada Quadra
            quadra_layer = QgsProject.instance().mapLayersByName('Quadra')
            if not quadra_layer:
                show_notification("Erro", "Camada 'Quadra' não encontrada no projeto!", "error")
              
                return False
            
            quadra_layer = quadra_layer[0]
            if quadra_layer.selectedFeatureCount() == 0:
                show_notification("warning", "Selecione ao menos uma feição na camada 'Quadra' antes de executar!", "warning")
              
                return False

            # Verifica camada de linhas de corte
            linhas_corte_layer = QgsProject.instance().mapLayersByName('Linhas_corte')
            if not linhas_corte_layer:

                show_notification("Erro", "Camada 'Linhas_corte' não encontrada no projeto!", "error")
              
                QMessageBox.critical(
                    self.dlg,
                    "Erro",
                    "Camada 'Linhas_corte' não encontrada no projeto!"
                )
                return False

            # Cria feedback para mostrar progresso
            feedback = QgsProcessingMultiStepFeedback(12, None)
            
            # Dicionário para armazenar outputs
            outputs = {}

            # Passo 1: Extrair feições selecionadas
            feedback.setCurrentStep(0)
            alg_params = {
                'INPUT': quadra_layer,
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['ExtrairFeicoes'] = processing.run(
                'native:saveselectedfeatures', 
                alg_params, 
                feedback=feedback
            )

            # Passo 2: Extrair por localização
            feedback.setCurrentStep(1)
            alg_params = {
                'INPUT': linhas_corte_layer[0],
                'INTERSECT': outputs['ExtrairFeicoes']['OUTPUT'],
                'PREDICATE': [0],
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['ExtrairPorLocalizacao'] = processing.run(
                'native:extractbylocation',
                alg_params,
                feedback=feedback
            )

            # Passo 3: Polígonos para linhas
            feedback.setCurrentStep(2)
            alg_params = {
                'INPUT': outputs['ExtrairFeicoes']['OUTPUT'],
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['PoligonosParaLinhas'] = processing.run(
                'native:polygonstolines',
                alg_params,
                feedback=feedback
            )

            # Passo 4: Estender linhas
            feedback.setCurrentStep(3)
            alg_params = {
                'END_DISTANCE': 0.3,
                'INPUT': outputs['ExtrairPorLocalizacao']['OUTPUT'],
                'START_DISTANCE': 0.3,
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['EstenderLinhas'] = processing.run(
                'native:extendlines',
                alg_params,
                feedback=feedback
            )

            # Passo 5: Mesclar camadas vetoriais
            feedback.setCurrentStep(4)
            alg_params = {
                'CRS': None,
                'LAYERS': [
                    outputs['EstenderLinhas']['OUTPUT'],
                    outputs['PoligonosParaLinhas']['OUTPUT']
                ],
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['MesclarCamadas'] = processing.run(
                'native:mergevectorlayers',
                alg_params,
                feedback=feedback
            )

            # Passo 6: Simplificar
            feedback.setCurrentStep(5)
            alg_params = {
                'INPUT': outputs['MesclarCamadas']['OUTPUT'],
                'METHOD': 0,
                'TOLERANCE': 0.001,
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['Simplificar'] = processing.run(
                'native:simplifygeometries',
                alg_params,
                feedback=feedback
            )

            # Passo 7: Poligonizar
            feedback.setCurrentStep(6)
            alg_params = {
                'INPUT': outputs['Simplificar']['OUTPUT'],
                'KEEP_FIELDS': False,
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['Poligonizar'] = processing.run(
                'native:polygonize',
                alg_params,
                feedback=feedback
            )

            # Passo 8: Remover vértices duplicados 1
            feedback.setCurrentStep(7)
            alg_params = {
                'INPUT': outputs['Poligonizar']['OUTPUT'],
                'TOLERANCE': 1e-06,
                'USE_Z_VALUE': False,
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['RemoverDuplicados1'] = processing.run(
                'native:removeduplicatevertices',
                alg_params,
                feedback=feedback
            )

            # Passo 9: Remover vértices duplicados 2
            feedback.setCurrentStep(8)
            alg_params = {
                'INPUT': outputs['RemoverDuplicados1']['OUTPUT'],
                'TOLERANCE': 1e-06,
                'USE_Z_VALUE': False,
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['RemoverDuplicados2'] = processing.run(
                'native:removeduplicatevertices',
                alg_params,
                feedback=feedback
            )

            # Passo 10: Ajustar geometrias
            feedback.setCurrentStep(9)
            alg_params = {
                'BEHAVIOR': 0,
                'INPUT': outputs['RemoverDuplicados2']['OUTPUT'],
                'REFERENCE_LAYER': outputs['RemoverDuplicados2']['OUTPUT'],
                'TOLERANCE': 0.0001,
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['AjustarGeometrias'] = processing.run(
                'native:snapgeometries',
                alg_params,
                feedback=feedback
            )

            # Passo 11: Editar campos
            feedback.setCurrentStep(10)
            alg_params = {
                'FIELDS_MAPPING': [
                    {'expression': 'aggregate(layer:=\'Quadra\', aggregate:=\'max\', expression:="id_localidade", filter:=intersects($geometry, geometry(@parent)))',
                     'length': -1, 'name': 'id_localidade', 'precision': 0, 'type': 4},
                    {'expression': 'aggregate(layer:=\'Quadra\', aggregate:=\'max\', expression:="id_setor", filter:=intersects($geometry, geometry(@parent)))',
                     'length': -1, 'name': 'id_setor', 'precision': 0, 'type': 4},
                    {'expression': 'aggregate(layer:=\'Quadra\', aggregate:=\'max\', expression:="id_bairro", filter:=intersects($geometry, geometry(@parent)))',
                     'length': -1, 'name': 'id_bairro', 'precision': 0, 'type': 4},
                    {'expression': 'aggregate(layer:=\'Quadra\', aggregate:=\'max\', expression:="id", filter:=intersects($geometry, geometry(@parent)))',
                     'length': -1, 'name': 'id_quadra', 'precision': 0, 'type': 4},
                    {'expression': 'aggregate(layer:=\'Quadra\', aggregate:=\'max\', expression:="ins_quadra", filter:=intersects($geometry, geometry(@parent)))',
                     'length': -1, 'name': 'ins_quadra', 'precision': 0, 'type': 4},
                    {'expression': '\'Habitado\'',
                     'length': -1, 'name': 'sit_imovel', 'precision': 0, 'type': 10},
                    {'expression': '@user_account_name || \' - \' || @user_full_name',
                     'length': -1, 'name': 'usuario', 'precision': 0, 'type': 10},
                    {'expression': 'to_date(now())',
                     'length': -1, 'name': 'data_atual', 'precision': 0, 'type': 14}
                ],
                'INPUT': outputs['AjustarGeometrias']['OUTPUT'],
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['EditarCampos'] = processing.run(
                'native:refactorfields',
                alg_params,
                feedback=feedback
            )

            # Passo 12: Exportar polígonos para PostgreSQL
            feedback.setCurrentStep(11)
            alg_params = {
                'ADDFIELDS': False,
                'APPEND': True,
                'A_SRS': QgsCoordinateReferenceSystem('EPSG:31984'),
                'CLIP': False,
                'DATABASE': conexao_nome,
                'DIM': 0,
                'GEOCOLUMN': 'geom',
                'GT': None,
                'GTYPE': 3,
                'INDEX': False,
                'INPUT': outputs['EditarCampos']['OUTPUT'],
                'LAUNDER': False,
                'OPTIONS': '',
                'OVERWRITE': False,
                'PK': '',
                'PRECISION': True,
                'PRIMARY_KEY': '',
                'PROMOTETOMULTI': False,
                'SCHEMA': 'comercial_umc',
                'SEGMENTIZE': '',
                'SHAPE_ENCODING': '',
                'SIMPLIFY': '',
                'SKIPFAILURES': False,
                'SPAT': None,
                'S_SRS': None,
                'TABLE': 'v_lote',
                'T_SRS': None,
                'WHERE': ''
            }
            processing.run(
                'gdal:importvectorintopostgisdatabaseavailableconnections',
                alg_params,
                feedback=feedback
            )

            # Adiciona as linhas de corte como camada temporária no projeto
            self.adicionar_linhas_corte_temporarias(outputs['EstenderLinhas']['OUTPUT'])

            # Força atualização da camada no canvas
            self.atualizar_camada_lotes()

            show_notification("Concluído", f"Poligonização concluída com sucesso!\n Total de lotes gerados: {len(list(outputs['EditarCampos']['OUTPUT'].getFeatures()))}", "success")
           
           
            return True

        except Exception as e:
            import traceback
            show_notification("Erro", f"Erro ao executar poligonização:\n{str(e)}\n\n{traceback.format_exc()}", "Error")
            
            return False
#Executado quando usuário clica no botão do plugin.
   
    def on_cancelar(self):
        """Callback quando o botão Cancelar é pressionado"""
        # Restaura a ferramenta de mapa anterior se existir
        if self.previous_map_tool:
            self.iface.mapCanvas().setMapTool(self.previous_map_tool)
            self.previous_map_tool = None
        
        # Fecha o diálogo
        self.dlg.close()

    def run(self):
            """Run method that performs all the real work"""

            # Create the dialog with elements (after translation) and keep reference
            # Only create GUI ONCE in callback, so that it will only load when the plugin is started
            if self.first_start == True:
                self.first_start = False
                self.dlg = PoligonizadorDialog()
                
                # Conecta o botão de seleção de quadra ao método
                if hasattr(self.dlg, 'btn_selecionar'):
                    self.dlg.btn_selecionar.clicked.connect(self.selecionar_quadra)
                if hasattr(self.dlg, 'btn_cancelar'):
                    self.dlg.btn_cancelar.clicked.connect(self.on_cancelar)
                if hasattr(self.dlg, 'btn_ok'):
                    self.dlg.btn_ok.clicked.connect(self.finalizar_selecao_quadras)
                    

            # Popula as conexões sempre que abrir o diálogo
            self.popular_conexoes()

            # show the dialog
          
            # Run the dialog event loop
            result = self.dlg.show()
            # See if OK was pressed
            if result:
                conexao_selecionada = self.dlg.combo_conexao.currentData()
                if conexao_selecionada:
                    self.executar_poligonizacao(conexao_selecionada)
                else:
                 show_notification("Aviso", "Selecione uma conexão!", "warning", 3000)
            return {}